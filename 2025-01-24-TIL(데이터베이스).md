# TIL: 데이터베이스
## 학습날짜: 2025년 1월 24일

## Problem: 
- SQL 심화 이해도 부족 

## Solution:
- 실습을 통한 체화

## What I Learned

### WITH 문
- CTE를 정의하기 위한 구문으로 서브쿼리를 재사용 가능하고 가독성 높게 작성할 수 있도록 지원
- 복잡한 쿼리를 읽기 쉽고 관리 가능하게 구조화
- 동일한 서브쿼리를 반복적으로 재잓어 하지 않아도 됨
- 재귀 쿼리작성 시 활용
```SQL
--WITH 문
WITH DEPARTMENTSALARY AS(
    SELECT DEPARTMENT_ID, ROUND(AVG(SALARY),2) AS AVG_SAL
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID
    ORDER BY DEPARTMENT_ID NULLS LAST)
SELECT * 
FROM DEPARTMENTSALARY
WHERE AVG_SAL > 5000;

--재귀CTE
WITH NUMBERS(NUM) AS(
    SELECT 1 AS NUM
    FROM DUAL
    UNION ALL
    SELECT NUM + 1 AS NUM
    FROM NUMBERS
    WHERE NUM < 10
    )
SELECT B.NUM
FROM NUMBERS B;
```
- CTE는 임시적으로 데이터를 메모리에 저장하여 처리 PGA 이용
- PGA 부족할경우 TEMP TABLESAPCE 사용
- CTE의 결과를 도출하는 데에복잡한 계산이 이루어지고 데이터량이 많은 경우에는 초기 비용이 들더라도 TEMP 영역에 저장해 두는 것이 유리할 수 있음
- 반대 경우에는 TEMP 영역에 저장하는 것이 더 커버릴 가능성이 존재하기 때문에 PGA로 해결 가능한지 확인 필요
- 데이터 정렬 작업에서 메모리를 다사용하면 TEMP TABLESPACE에 데이터를 기록


### JOIN
-NESTED LOOP JOIN
중첩 FOR문과 유사한 형태, DRIVING처리 범위에 의해 전체 일량이 결정
JOIN컬럼이 DRIVEN 테이블의 INDEX로 설정되어 있어야 유리, OLTP성 쿼리에 적합
USE_NL 으로 옵티마이저 설정 변경 가능
- HASH JOIN
JOIN 컬럼에 인덱스가 없어 NL JOIN이 효과적이지 못한 상황에 대한 대안
인덱스가 있지만 DRIVING에서 DRIVEN로의 엑세스량이 많아 RANDOM ACCESS부하가 심한 경우
수행빈도가 낮고 시간이 오래걸리는 OLAP성 쿼리에 적합
인덱스는 한 번 생성해 놓으면 영구적으로 사용하는 오브젝트인 반면 HASH TABLE은 단 하나의 쿼리를 위해 생성하고 JOIN이 끝나고 바로 소멸하는 자료구조
-수행시간이 짧으면서 수행빈도가 매우 높은 OLTP성 쿼릴를 HASH JOIN으로 초리한다면 CPU와 메모리 사용률 크게 증가
-수행빈도가 낮고 쿼리 수행 시간이 오래 걸리는 대용량 테이블을 JOIN할 때 사용(EX. BATCH성 쿼리)

### 실행계획
- SQL로 요청한 데이터를 어떻게 꺼내 올 것인가에 대한 PLAN
- 성능 병목 현상을 파악하는 데 유용
- 높은 확률로 OPTIMIZER가 결정한 실행 계획이 최선인 경우가 많음
- 이따금씩 Optimizer의 실행 계획이 잘못되었을 경우 적절한 힌트를 사용하여튜닝

### 사용자 정의 함수
- 사용자가 특정 작업을 수행하기 위해 정의한 PL/SQL 코드 블록
- 반복적인 작업을 자동화하고 코드 재사용성을 높이기 위해 사용
- 주로 입력 값을 받아 처리 후 결과를 반환

### REDO/ UNDO
- REDO: 데이터베이스 변경 내용을 복구하기 위한 로그\
- UNDO: 데이터 변경 이전 상태를 저장하여 롤백하거나 트랜잭션을 취소할 수 있게 함
- 데이터 무결성과 복구 기능을 제공

### SQL INJECTION
- 공격자가 입력 필드나 URL에 악의적인 SQL코드를 삽입하여 데이터베이스를 조작하는 공격 기법
- 목적: 민감한 데이터 유출/ 데이터 변경/ 시스템 권한 탈취

