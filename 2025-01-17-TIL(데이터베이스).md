# TIL: 데이터베이스
## 학습날짜: 2025년 1월 17일

## Problem: 
- GROUP BY, ORDER BY, HAVING, JOIN 연습 필요

## Solution:
- 예제 문제 풀이를 통한 연습

## What I Learned

### ORDER BY
- 데이터를 정렬하는 데 사용되는 절
- 기본적으로 오름차순 정렬 ASC , 내림차순 정렬 시 DESC
- 하나 이상의 컬럼을 기준으로 정렬 가능
- ORACLE에서는 NULL 값은 최대값으로 간주

### GRUOP BY
- 데이터를 특정 기준으로 묶는 작업
- 집계 함수와 함께 사용하여 그룹별 요약 정보 제공 (COUNT, SUM, AVG, MAX, MIN)
- WHERE 와 함께 사용 가능

### HAVING
- GROUP BY 이후 그룹별 조건 필터링

### 작동 순서 TIL: 데이터베이스
## 학습날짜: 2025년 1월 17일

## Problem: 
- GROUP BY, ORDER BY, HAVING, JOIN 연습 필요

## Solution:
- 예제 문제 풀이를 통한 연습

## What I Learned

### ORDER BY
- 데이터를 정렬하는 데 사용되는 절
- 기본적으로 오름차순 정렬 ASC , 내림차순 정렬 시 DESC
- 하나 이상의 컬럼을 기준으로 정렬 가능
- ORACLE에서는 NULL 값은 최대값으로 간주

### GRUOP BY
- 데이터를 특정 기준으로 묶는 작업
- 집계 함수와 함께 사용하여 그룹별 요약 정보 제공 (COUNT, SUM, AVG, MAX, MIN)
- WHERE 와 함께 사용 가능

### HAVING
- GROUP BY 이후 그룹별 조건 필터링

### 진행 순서
![image](https://github.com/user-attachments/assets/2936a26e-e310-4cf6-b2d5-80bdbaad1358)


## 실습
``` SQL
--1. 직업 변경이력 있는 직원 없을경우 NOCHANGE
SELECT E.NAME, NVL(J.JOB_ID, 'No Change')
FROM EMPLOYEES E 
LEFT OUTER JOIN JOB_HISTORY J ON E.EMPLOYEE_ID = J.EMPLOYEE_ID;

--2. 특정 패턴의 직원과 부서 정보 조회, 
--직원 이름에 특정 문자열이 포함된 데이터 조회 / 급여 NULL 처리
SELECT E.NAME, NVL(E.SALARY, 0), D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.NAME LIKE '%Employee 1%'
ORDER BY D.DEPARTMENT_NAME;

--3.최근 6개월 거래 내역 조회
SELECT T.ACCOUNT_ID, TO_CHAR(T.TRANSACTION_DATE,'YYYY-MM-DD HH24:Mi:SS'), C.CUSTOMER_ID, C.NAME
FROM TRANSACTIONS T
JOIN ACCOUNTS A ON T.ACCOUNT_ID = A.ACCOUNT_ID
JOIN CUSTOMERS C ON A.CUSTOMER_ID = C.CUSTOMER_ID
WHERE SYSDATE - T.TRANSACTION_DATE <= 180;
--WHERE T.TRANSACTION_DATE >= ADD_MONTHS(SYSDATE, -6);

--4.특정 부서의 직무별 직무별 직원수
SELECT E.JOB_ID, COUNT(*)
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE D.DEPARTMENT_NAME IN ('Department 3', 'Department 4', 'Department 5', 'Department 6')
GROUP BY E.JOB_ID;

--5.계좌 유형별 평균 잔액
SELECT ACCOUNT_TYPE TYPE, TRUNC(AVG(BALANCE),2) AVG_BAL
FROM ACCOUNTS
GROUP BY ACCOUNT_TYPE
ORDER BY AVG(BALANCE) DESC;

--6.각 계좌별 거래 횟수
SELECT A.ACCOUNT_ID, COUNT(T.TRANSACTION_ID)
FROM ACCOUNTS A
LEFT OUTER JOIN TRANSACTIONS T ON A.ACCOUNT_ID = T.ACCOUNT_ID
GROUP BY A.ACCOUNT_ID
ORDER BY COUNT(T.TRANSACTION_ID) ASC;

--7.특정 기간의 고객별 총 거래 내역
SELECT C.NAME, SUM(T.AMOUNT) TOTAL
FROM TRANSACTIONS T
JOIN ACCOUNTS A ON A.ACCOUNT_ID = T.ACCOUNT_ID
JOIN CUSTOMERS C ON C.CUSTOMER_ID = A.CUSTOMER_ID
WHERE T.TRANSACTION_DATE BETWEEN TO_DATE('2024-01-01', 'YYYY-MM-DD') AND TO_DATE('2025-12-31', 'YYYY-MM-DD')
GROUP BY C.NAME
ORDER BY TOTAL DESC
FETCH FIRST 10 ROW ONLY;

--8.급여가 NULL인 직원
SELECT E.NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE SALARY IS NULL;

--9.

SELECT C.NAME, MAX(L.AMOUNT)
FROM LOANS L
JOIN CUSTOMERS C ON L.CUSTOMER_ID = C.CUSTOMER_ID
GROUP BY C.NAME, L.CUSTOMER_ID;

--10.특정 급여 구간과 부서별 직원 분포
SELECT D.DEPARTMENT_NAME, COUNT(*) PEOPLE
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.SALARY BETWEEN 7000 AND 15000
GROUP BY D.DEPARTMENT_NAME
HAVING COUNT(*) >= 5
ORDER BY COUNT(*) DESC;
```





