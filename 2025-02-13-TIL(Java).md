# TIL: JAVA
## 학습날짜: 2025년 2월 13일

## Problem:
- 한 주 동안 배운 MyBatis, JDBC, JavaFx, Dependency Injection 을 모두 적용한 프로젝트 경험이 없음

## Solution:
- 그동안 배운 모든 것을 적용한 프로젝트 실습

## What I Learned

### JDBC library
- SQL과 Java가 하나의 file에 공존(DAO)
- 별도의 framework, library를 사용하면 SQL코드를 다른 곳에 위임할 수 있음
- MyBatis, ORM(Hibernate) -> Query의 복잡도에 따라서 선택

### MyBatis
- SQL구문과 Java코드를 분리할 수 있음
- SQL의 실행 결과를 Map에 매핑 시켜줌
- DataSource 기능, Transaction 기능 제공

### Connection pool
- 여러 사용자가 하나의 데이터베이스를 사용할 경우 부하가 발생할 확률이 높아짐
- connection pool에서 미리 연결을 여러개 생성해 놓고 데이터 베이스 사이에서 중간 다리 역할을 함

### MyBatis 연결실습
- configuration
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org/DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd" >
<configuration>
    <!-- JDBC Driver class 와 데이터베이스 연결 설정 -->
    <!-- 연결 설정에 대한 내용은 XML 내부에 직접 작성하지 않음
         별도의 외부파일에 작성해서 해당 파일을 property로 가져와서 사용-->
    <properties resource="./driver.properties"/>
    <!-- MyBatis 실행 설정 -->
    <!-- 많은 설정 대부분은 default 사용-->
    <settings>
        <setting name="jdbcTypeForNull" value="NULL"/>
    </settings>
    <!-- TypeAlias -->
    <typeAliases>
        <typeAlias alias="Book" type="practice0213.vo.BookVO" />
    </typeAliases>
    <environments default="development">
        <environment id="development">
            <!-- TransactionManager 를 JDBC 로 설정 시 수동으로
                 Transaction 을 관리 ( commit(), rollback()을 코드에서 제어

                 type 을 MANAGED 로 설정하면 자동으로 transaction 제어-->
            <transactionManager type="JDBC">

            </transactionManager>

            <dataSource type="POOLED">
                <property name="driver" value="${db.driver}"/>
                <property name="url" value="${db.url}"/>
                <property name="username" value="${db.username}"/>
                <property name="password" value="${db.password}"/>
            </dataSource>
        </environment>
    </environments>
    <!-- SQL 구문을 작성하는 mapper 라는 xml 파일의 경로를 지정-->
    <mappers>
        <mapper resource="./sqlmap/Book.xml"/>
    </mappers>
</configuration>
```
- properties ( 보안을 위해 직접 코드에 넣지 않음)
```
db.driver=oracle.jdbc.driver.OracleDriver
db.url=jdbc:oracle:thin:@localhost:1521:xe
db.username=system
db.password=1234
```
- mapping을 위한 xml ( 실제 query가 들어감 )
```xml
<?xml version="1.0" encoding="UTF-8"?> 
<!DOCTYPE mapper 
        PUBLIC "-//mybatis.org/DTD Mapper 3.0//EN" 
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="practice0213.MyBook">
    <!-- CDATA 는 SQL query 내부의 특수문자(<>)가 tag로 인식되지 않도록 처리 -->
    <select id="selectByISBNHashMap" parameterType="String"
        resultType="HashMap">
        <![CDATA[
            SELECT bisbn, btitle, bprice, bauthor
            FROM BOOK
            WHERE bisbn = #{bisbn}
        ]]>
    </select>
    <select id="selectAllHashMap"
            resultType="HashMap">
        <![CDATA[
        SELECT bisbn, btitle, bprice, bauthor
        FROM BOOK
        ]]>
    </select>
    <select id="selectByBISBNBookVO" parameterType="String"
            resultType="Book">
        <![CDATA[
        SELECT bisbn, btitle, bprice, bauthor
        FROM BOOK
        WHERE BISBN = #{s}
        ]]>
    </select>
    <select id="selectBookByTitle" parameterType="String" resultType="Book">
    <![CDATA[
        SELECT bisbn, btitle, bprice, bauthor
        FROM BOOK
        WHERE BTITLE LIKE '%' || #{s} || '%'
        ]]>
    </select>
    <delete id="deleteBookByIsbn" parameterType="String">
    <![CDATA[
        DELETE FROM BOOK
        WHERE bisbn = #{bisbn}
        ]]>
    </delete>
    <insert id="insertBook" parameterType="practice0213.vo.BookVO">
    <![CDATA[
        INSERT INTO BOOK (bisbn, btitle, bprice, bauthor)
        VALUES (#{bisbn}, #{btitle}, #{bprice}, #{bauthor})
        ]]>
    </insert>
</mapper>
```
- SessionFactory java class (resource의 configuration 파일을 읽어들여 SqlSession 제공)
```java
package example.MyBatis;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.Reader;

//  sqlSessionFactory 라는 객체가 DAO 에서 필요
//  이 객체를 통해서 sqlSession 객체를 가져올 수 있음
//  이 sqlSession 객체를 이용해서 SQL 문을 실행할 수 있음
public class MyBatisSessionFactory {
    private static SqlSessionFactory sqlSessionFactory;

    static {
        try{
            String resource = "./SqlMapConfig.xml";
            Reader reader = Resources.getResourceAsReader(resource);

            if(sqlSessionFactory==null){
                sqlSessionFactory =
                        new SqlSessionFactoryBuilder().build(reader);
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    public static SqlSessionFactory getSqlSessionFactory(){
        return sqlSessionFactory;
    }
}
```
