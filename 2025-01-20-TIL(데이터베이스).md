# TIL: 데이터베이스
## 학습날짜: 2025년 1월 20일

## Problem: 
- 쿼리의 성능을 향상시키기 위한 다양한 방법에 대한 이해도 부족

## Solution:
- 같은 쿼리를 다른 방식으로 직접 작성해 보며 비교해보기

## What I Learned

### 서브쿼리
- SQL문 안에 포함된 또 다른 SQL문
- 메인 쿼리에 값을 제공하거나 조건을 지정하는 역할
- 일반적으로 괄호로 감싸져 있음
- 연관 여부에 따른 분류: 비연관 서브쿼리,  연관 서브쿼리
- 위치에 따른 분류: 스칼라 서브쿼리, 인라인 뷰, 중첩 서브쿼리
- 반환값 유형에 따른 분류: 단일 행 서브쿼리, 다중행 서브쿼리, 다중열 서브쿼리
- 사용 시 주의사항: 성능최적화 ( 비연관 서브쿼리는 독립적으로 실행되므로 더 빠름, 연관 서브쿼리는 메인 쿼리의 각 행마다 실행되므로 성능 저하 가능)
		               적절한 반환값 확인( 서브쿼리가 반환하는 값의 유형에 따라 연산자 선택이 중요
		               JOIN의 대체 가능성( 일부 서브쿼리는 JOIN과 대체 가능해 성능 개선 가능)

### 집합연산자
- SQL에서 두 개 이상의 SELECT 결과를 결합하여 하나의 결과 집합을 생성
- 데이터베이스에서 집합 이론을 기반으로 작동
- 서로 다른 쿼리의 결과를 비교하거나 결합할 때 유용
- 종류: UNION/ UNION ALL/ INTERSECT/ MINUS
- 사용 시 주의사항: SELECT 절에 나열된 컬럼 수와 데이터 타입이 동일해야 함
          		     결과 집합의 순서는 기본적으로 보장되지 않음
          			   ORDER BY는 최종 결과에만 적용 가능
          			   대량의 데이터 처리 시 성능에 유의해야 함
          			   ALIAS는 맨 처음 SELECT 절을 따름

### 윈도우 함수
- SQL에서 행(ROW)을 기준으로 특정 범위(WINDOW)를 정의하여 작업하는 함수
- 집계 함수와 함께 데이터를 그룹핑하지 않고도 계산 가능
- 주요 용도: 순위 계산/ 이동 평균/ 누적 합계/ 그룹별 최대값, 최솟값

### 연습 문제 풀이

```sql
--1.직원과 부서 정보를 조합하여 직무와 급여 통계
--모든 부서 직무별 평균 급여/ 해당직무 가장 높은 급여
--부서이름/직무ID/평균급여/최대급여/ 평균급여가 8000이상인 결과만 조회 /평균급여 기준으로 내림차순정렬
--평균 급여는 반올림하여 소수점 아래 둘째자리까지
SELECT DEPARTMENT_NAME, DEPARTMENT_ID,
    ROUND((SELECT AVG(SALARY) 
       FROM EMPLOYEES 
       WHERE DEPARTMENT_ID = D.DEPARTMENT_ID), 2) AS AVG_SALARY,
    (SELECT MAX(SALARY) 
        FROM EMPLOYEES 
        WHERE DEPARTMENT_ID = D.DEPARTMENT_ID) AS MAX_SALARY
FROM DEPARTMENTS D
ORDER BY AVG_SALARY DESC NULLS LAST;

--2. 5년 이내에 입사한 직원들의 급여와 전체 직원 급여 비교
SELECT DEPT, CEIL(AVG_SALARY)
FROM (
    SELECT AVG(E.SALARY) AS AVG_SALARY, D.DEPARTMENT_ID AS DEPT
    FROM EMPLOYEES E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    WHERE SYSDATE - E.HIRE_DATE <= 1825 -- 5년
    GROUP BY D.DEPARTMENT_ID
)
WHERE AVG_SALARY >= (SELECT AVG(E1.SALARY) FROM EMPLOYEES E1);

--3. 특정 지역의 지점에서 대출을 받은 고객 조회
SELECT (SELECT NAME FROM CUSTOMERS WHERE CUSTOMER_ID = L.CUSTOMER_ID) AS NAME, AMOUNT, STATUS
FROM LOANS L
WHERE BRANCH_ID IN (SELECT B.BRANCH_ID FROM BRANCHES B WHERE B.LOCATION = 'Location 4') AND L.AMOUNT >= 50000;

--4.대출 상태가 PENDING인 고객과 REJECTED인 고객의 교집합
SELECT NAME, EMAIL, PHONE 
FROM CUSTOMERS C JOIN LOANS L ON C.CUSTOMER_ID = L.CUSTOMER_ID
WHERE STATUS = 'PENDING'
INTERSECT
SELECT NAME, EMAIL, PHONE 
FROM CUSTOMERS C JOIN LOANS L ON C.CUSTOMER_ID = L.CUSTOMER_ID
WHERE STATUS = 'REJECTED';

--5. 대출 상태와 계좌 잔액 통계 병합.
--계좌 잔액이 50,000 이상인 고객과 대출 상태가 'PENDING'인 고객을 병합하여 결과를 조회하세요. 
--출력 데이터는 [고객 이름], [계좌 잔액 및 대출 금액 = 동일 컬럼] 이며 
--헤더명은 “고객 이름”, “금액” 으로 표시하고 고객 이름으로 오른차순 정렬합니다.
SELECT NAME 고객이름, BALANCE 금액 FROM CUSTOMERS C JOIN ACCOUNTS A ON C.CUSTOMER_ID = A.CUSTOMER_ID
WHERE BALANCE >= 50000
UNION
SELECT NAME, AMOUNT FROM LOANS L JOIN CUSTOMERS C ON C.CUSTOMER_ID = L.CUSTOMER_ID 
WHERE STATUS = 'PENDING'
ORDER BY 고객이름;
```


