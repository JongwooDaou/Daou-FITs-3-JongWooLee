# TIL: 데이터베이스
## 학습날짜: 2025년 1월 21일

## Problem: 
- 다양한 함수와 계층 쿼리 사용 부족

## Solution:
- 동일한 결과 값을 내는 다양한 코드를 직접 작성해봄

## What I Learned

### 윈도우 함수 옵션
- 윈도우 함수에서 특정 행이나 범위를 지정하는 추가 설정
- 옵션을 활용해 데이터 처리 범위를 유연하게 조정 가능
- ROWS: 물리적 행을 기준으로 범위를 지정
- RANGE: 논리적 값을 기준으로 범위를 지정
- UNBOUNDED PRECEDING: 윈도우의 시작 범위를 첫 번째 행으로 지정
- CURRENT ROW: 현재 행을 기준으로 윈도우 설정
- FOLLOWING: 현재 행 이후의 특정 행 범위를 설정

### 계층쿼리
- 데이터가 부모-자식 관계로 구성된 계층적 구조를 조회하기 위한 쿼리
- 트리 구조 데이터를 표현하고 탐색하는 데 사용
- START WITH: 계층 구조의 시작점 지정
- CONNECT BY: 부모-자식 관계를 정의
- PRIOR: 계층의 방향성을 설정
- ORDER SIBLINGS BY: 동일 레벨의 데이터 정렬
- LEVEL: 계층 깊이를 나타내는 가상 컬럼

### 실습 1-10
``` sql
--1. 직무별 상위 3명의 직원
--각 직무별로 급여가 가장 높은 3명의 직원 정보를 조회하세요. 
--출력 컬럼은 직무, 사번, 이름, 급여, 순위이고 직무, 순위로 정렬합니다.
SELECT *
FROM(
    SELECT JOB_ID, EMPLOYEE_ID, NAME,SALARY, 
        RANK() OVER(PARTITION BY JOB_ID ORDER BY SALARY DESC NULLS LAST) AS RANK
    FROM EMPLOYEES
)
WHERE RANK <= 3;

--2. 직원 입사 연도별 총 급여 및 누적 급여
--직원들의 입사 연도별 총 급여와 
--해당 연도의 누적 급여를 계산하세요.
SELECT HIRE_YEAR, TOTAL_SALARY,
    SUM(TOTAL_SALARY) OVER(ORDER BY HIRE_YEAR) AS CUM_SUM_SAL
FROM(
    SELECT 
        DISTINCT TO_CHAR(HIRE_DATE, 'YYYY') AS HIRE_YEAR,
        SUM(SALARY) OVER(PARTITION BY TO_CHAR(HIRE_DATE, 'YYYY')) AS TOTAL_SALARY
    FROM EMPLOYEES
);



--3. 직원별 급여 순위와 부서 평균 급여 비교
--모든 직원에 대해 급여 순위를 계산하고, 각 직원의 급여가 부서 평균 급여보다 높은지 확인하세요. 
--부서 평균 급여보다 높은 경우 ‘높다’라고 출력하고 낮은 경우 ‘낮다’라고 출력합니다. 
--(출력 컬럼은 사번, 이름, 급여, 급여 순위, 부서 평균 급여, 높은지 낮은지 여부)
SELECT EMPLOYEE_ID, SALARY, RANK_SAL, DEPT_AVG_SAL,
    CASE 
        WHEN SALARY > DEPT_AVG_SAL THEN 'HIGH'
        ELSE 'LOW'
    END
FROM (
    SELECT EMPLOYEE_ID, SALARY, 
        RANK() OVER (ORDER BY SALARY DESC NULLS LAST) AS RANK_SAL,
        AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS DEPT_AVG_SAL
    FROM EMPLOYEES
);


--4. 최근 1년간 대출을 받은 고객 중 총 대출 금액 상위 5명
--최근 1년 동안 대출을 받은 고객의 총 대출 금액을 계산하고, 
--이 금액이 상위 5명인 고객의 이름과 대출 금액을 출력하세요.

SELECT NAME, SUM_AMOUNT
FROM(
    SELECT DISTINCT CUSTOMER_ID, 
            SUM(AMOUNT) 
            OVER (PARTITION BY CUSTOMER_ID) AS SUM_AMOUNT
        FROM LOANS
        WHERE SYSDATE - LOAN_DATE <= 365
    ORDER BY SUM_AMOUNT DESC
) A
JOIN CUSTOMERS C ON A.CUSTOMER_ID = C.CUSTOMER_ID
WHERE ROWNUM <= 5;
--5. 이동 평균 (Moving Average)
--직원 테이블에서 직원의 급여(SALARY)를 기준으로 직원 ID 순서대로 3명의 이동 평균을 계산하세요. 
--여기서 이동 평균은 현재 직원의 급여와 바로 이전 직원 2명의 급여를 포함합니다. 
--직원 ID, 이름, 급여, 그리고 이동 평균을 출력하세요. 
--이동 평균값은 반올림하여 소수점 아래 둘째 자리까지 표현합니다.
SELECT EMPLOYEE_ID, NAME, SALARY,
    ROUND(AVG(SALARY) OVER(ORDER BY EMPLOYEE_ID ROWS BETWEEN 2 PRECEDING AND CURRENT ROW),2) 
    AS MOVING_AVG_SAL
FROM EMPLOYEES;

--6. 계좌 잔액이 평균 잔액 이상인 고객과 대출 금액이 평균 대출 금액 이상인 고객의 병합
--계좌 잔액이 전 계좌의 평균 잔액 이상인 고객과 대출 금액이 전체 평균 대출 금액 이상인 고객을 
--병합하여 고객 이름과 금액을 조회하세요. 
--출력 데이터에 출처가 “계좌” 인지 “대출”인지도 하나의 컬럼으로 나타내 주세요.
SELECT 
    CUSTOMER_ID,
    BALANCE,
    '계좌' AS 계좌
FROM ACCOUNTS
WHERE BALANCE >= (SELECT AVG(BALANCE) FROM ACCOUNTS)
UNION
SELECT
    CUSTOMER_ID,
    AMOUNT,
    '대출' AS 대출
FROM LOANS
WHERE AMOUNT >= (SELECT AVG(AMOUNT) FROM LOANS);

SELECT A.CUSTOMER_ID, BALANCE, 계좌, AMOUNT, 대출
FROM(
    SELECT 
    CUSTOMER_ID,
    BALANCE,
    '계좌' AS 계좌
    FROM ACCOUNTS
    WHERE BALANCE >= (SELECT AVG(BALANCE) FROM ACCOUNTS)
) A 
JOIN(
    SELECT
        CUSTOMER_ID,
        AMOUNT,
        '대출' AS 대출
    FROM LOANS
    WHERE AMOUNT >= (SELECT AVG(AMOUNT) FROM LOANS)
) B ON A.CUSTOMER_ID = B.CUSTOMER_ID;

--7



--8 
SELECT 
    DISTINCT BRANCH_ID,
    COUNT(*) OVER (PARTITION BY BRANCH_ID) AS TOTAL_LOANS,
    SUM(CASE WHEN STATUS = 'APPROVED' THEN 1 ELSE 0 END) 
        OVER (PARTITION BY BRANCH_ID) AS APPROVED_LOANS,
    ROUND(
        SUM(CASE WHEN STATUS = 'APPROVED' THEN 1 ELSE 0 END) 
        OVER (PARTITION BY BRANCH_ID) * 100 / 
        COUNT(*) OVER (PARTITION BY BRANCH_ID), 
        2
    ) AS APPROVAL_RATE
FROM LOANS
ORDER BY BRANCH_ID;



--9.
SELECT *
FROM(
    SELECT NAME, JOB_ID,
        RANK() OVER(PARTITION BY JOB_ID ORDER BY SALARY) RANK
    FROM EMPLOYEES
)
WHERE RANK = 1;



--10
SELECT A.DEPARTMENT_ID, YES_BOSS, NO_BOSS
FROM (
    SELECT DEPARTMENT_ID, COUNT(*) YES_BOSS
    FROM EMPLOYEES
    WHERE MANAGER_ID IS NOT NULL AND DEPARTMENT_ID IS NOT NULL
    GROUP BY DEPARTMENT_ID) A 
FULL OUTER JOIN (
    SELECT DEPARTMENT_ID, COUNT(*) NO_BOSS
    FROM EMPLOYEES
    WHERE MANAGER_ID IS NULL AND DEPARTMENT_ID IS NOT NULL
    GROUP BY DEPARTMENT_ID) B 
ON A.DEPARTMENT_ID = B.DEPARTMENT_ID;
```
