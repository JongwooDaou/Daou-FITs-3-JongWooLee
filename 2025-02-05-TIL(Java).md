# TIL: JAVA
## 학습날짜: 2025년 2월 5일

## Problem:
- 자바의 상세한 구동에 관한 내용 이해도 부족

## Solution:
- 단순한 프로그램 제작이 아닌 기초 학습

## What I Learned


### 객체지향 (복습)
- 추상화 -> 객체모델링 -> 객체(instance) 생성
- class는 instance를 만들기 위한 설계도
- `instance` : heap영역의 메모리 공간 자체를 의미

### Java의 실행
- javac.exe : 컴파일러 .java -> .class로 변경
- java.exe : interpreter bytecode를 읽어들여서 실행

### JVM의 메모리 구조
- `Register` `Runtime Constant Pool` `Method Area` `Heap` `Call Stack`
- `Register` : 다음 코드에 대한 포인터를 관리
- `Runtime Constant Pool` : 실행 시 상수를 할당한 공간(Heap의 일부분)
- `Method Area` : class를 처음 사용하는 순간에 class의 정보를 할당  
                  static field 할당 
                  method의 실행코드 할당
- `Heap` : class를 통해 생성된 instance 모두 할당
- `Call Stack` : method를 위한 공간 할당(local variable을 할당)
```java
public class InstanceTest {
    static int k = 100;
    int h = 100;

    public InstanceTest(){
    }

    public static void main(String[] arg) {
        InstanceTest d1 = new InstanceTest();
        InstanceTest d2 = new InstanceTest();
        // d1.h != d2.h 힙영역에 할당된 인스턴스의 h값은 다른 곳에 할당 됨 값만 같음
        // d1.k == d2.k
        if(d1.h == d2.h){
            System.out.println("d1.equals(d2)");
        }
        // static일 경우에는 class명으로 직접 호출 가능
        System.out.println(InstanceTest.k);

    }
}
```

### access modifier(접근제어자)
- `public` : 어디에서나 접근 가능한 field, method, constructor, class 선언에 사용
- `protected` : 기본적으로 default와 같지만 상속관계에 있는 class에서 field, method, constructor를 사용할 수 있도록 선언
- `default` : 같은 package내의 다른 class에서 접근 가능한 field, method, constructor, class 선언
- `private` : 다른 class에서는 접근할 수 없는 field, method, constructor 선언

```java
//같은 file내부의 두개의 클래스 생성
package aaa;


public class PackageTest {
    // instance variable
    int k;

    // default constructor
    public PackageTest() {
    }

    public static void main(String[] args) {
        ClassForPackageTest a = new ClassForPackageTest();
        System.out.println("Hello World");
    }
}
// 컴파일 했을 때 class단위로 바이트코드가 생성되기 때문에 .class 파일 역시 생성됨
// 패키지는 aaa
//class앞에는 access modifier가 2가지 중 하나만 가능
// public, default(생략가능)
class ClassForPackageTest {
    public ClassForPackageTest() {
        System.out.println("ClassForPackageTest constructed");
    }
}
```

### static block
- static block은 class가 로드된 후 main thread에 의해서 main method가 호출되기 이전에 실행
```java
public class StaticBlock {

    int aaa;
    static int bbb = staticCall();

    public static int staticCall() {
        System.out.println("static method call()");
        return 100;
    }
    //static block
    static {
        System.out.println("이것은 Static block의 연습입니다. bbb의 값은 : " + bbb);
    }

    public static void main(String[] args) {
        System.out.println("main() 호출");
    }

}
```
```
//실행결과
static method call()
이것은 Static block의 연습입니다. bbb의 값은 : 100
main() 호출

Process finished with exit code 0
```


### inheritance(상속)
- 상속은 부모 class가 가진 내용을 자식 class가 물려받는 것이다.
- `Super class`, `Parent class`, `Upper class` : 부모 클래스
- `Sub class`, `Child class`, `lower class` : 자식 클래스
- Java는 다중상속을 허용하지 않음(C++의 경우 허용)
- 모든 class는 상속관계를 가지고있음(object 상속)

```java
//Super class
public class Person {
    String name;
    String phone;

    public Person() {
    }

    //method
    public void sleep(){

    }
    public void eat() {

    }
}

//Sub class
public class Student extends Person {
    String dept;

    public Student() {
    }
    
    //method
    public void study(){
        
    }
}

//Sub class
public class Teacher extends Person {

    String subject;

    public Teacher() {
    }
    
    //method
    public void teach(){
        
    }
}

```
