# TIL: JAVA
## 학습날짜: 2025년 2월 5일

## Problem:
- 

## Solution:
- 

## What I Learned


### 객체지향 (복습)
- 추상화 -> 객체모델링 -> 객체(instance) 생성
- class는 instance를 만들기 위한 설계도
- `instance` : heap영역의 메모리 공간 자체를 의미

### JVM의 메모리 구조
- `Register` `Runtime Constant Pool` `Method Area` `Heap` `Call Stack`
- `Register` : 다음 코드에 대한 포인터를 관리
- `Runtime Constant Pool` : 실행 시 상수를 할당한 공간(Heap의 일부분)
- `Method Area` : class를 처음 사용하는 순간에 class의 정보를 할당  
                  static field 할당 
                  method의 실행코드 할당
- `Heap` : class를 통해 생성된 instance 모두 할당
- `Call Stack` : method를 위한 공간 할당(local variable을 할당)
```java
public class InstanceTest {
    static int k = 100;
    int h = 100;

    public InstanceTest(){
    }

    public static void main(String[] arg) {
        InstanceTest d1 = new InstanceTest();
        InstanceTest d2 = new InstanceTest();
        // d1.h != d2.h 힙영역에 할당된 인스턴스의 h값은 다른 곳에 할당 됨 값만 같음
        // d1.k == d2.k
        if(d1.h == d2.h){
            System.out.println("d1.equals(d2)");
        }
        // static일 경우에는 class명으로 직접 호출 가능
        System.out.println(InstanceTest.k);

    }
}
```

### access modifier(접근제어자)
- `public` : 어디에서나 접근 가능한 field, method, constructor, class 선언에 사용
- `protected` : 기본적으로 default와 같지만 상속관계에 있는 class에서 field, method, constructor를 사용할 수 있도록 선언
- `default` : 같은 package내의 다른 class에서 접근 가능한 field, method, constructor, class 선언
- `private` : 다른 class에서는 접근할 수 없는 field, method, constructor 선언

```java
//같은 file내부의 두개의 클래스 생성
package aaa;


public class PackageTest {
    // instance variable
    int k;

    // default constructor
    public PackageTest() {
    }

    public static void main(String[] args) {
        ClassForPackageTest a = new ClassForPackageTest();
        System.out.println("Hello World");
    }
}
// 컴파일 했을 때 class단위로 바이트코드가 생성되기 때문에 .class 파일 역시 생성됨
// 패키지는 aaa
//class앞에는 access modifier가 2가지 중 하나만 가능
// public, default(생략가능)
class ClassForPackageTest {
    public ClassForPackageTest() {
        System.out.println("ClassForPackageTest constructed");
    }
}
```

