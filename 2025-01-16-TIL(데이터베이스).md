# TIL: 데이터베이스
## 학습날짜: 2025년 1월 16일

## Problem: 
- 실습 문제 풀이 부족

## Solution:
- 팀원들과 함께 실습 문제 풀이 후 공유

## What I Learned
### join
- 여러 테이블의 데이터를 결합하여 하나의 결과 집합을 생성
- 기본적으로 두 개 이상의 테이블을 연결
- 테이블 간 관계를 활용하여 데이터 조회
- 정규화 된 데이터를 조합하여 원하는 정보를 조회
- INNER JOIN: 두 테이블 간에 일치하는 데이터만 반환
  LEFT/RIGHT OUTER JOIN: 각 행에 일치하는 반대 테이블의 모든 데이터 반환 일치하지 않는 경우 NULL 반환
  FULL OUTER JOIN: 각 테이블의 모든 행 반환
  SELF JOIN: 같은 테이블을 두 번 사용, 주로 계층 구조 표현 ex)쇼핑몰의 소, 중, 대 분류
  CROSS JOIN: 두 테이블 간의 모든 행의 조합을 반환(카테시안 곱)
  NATURAL JOIN: 동일한 이름의 컬럼을 기준으로 JOIN, 조건을 명시하지 않아도 자동으로 연결
- 유의사항: 조건 누락 시 카테시안 곱만큼 반환함, NULL 처리 로직 필요, 큰 테이블 간 JOIN은 성능 저하 초래하기 때문에 적절한 INDEXING이 필요

## 실습 문제 풀이
``` sql
-- SQL 실전


--직원 부서명, 근무 지역 출력 
SELECT E.NAME, D.LOCATION
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

--self join
SELECT E1.NAME, E2.NAME 
FROM EMPLOYEES E1
LEFT OUTER JOIN EMPLOYEES E2 ON E1.MANAGER_ID = E2.EMPLOYEE_ID;
--직원 명, 봉급 없을 시 'N/A'
SELECT NAME, NVL2(SALARY, TO_CHAR(SALARY), 'N/A') AS SALARY
FROM EMPLOYEES;
-- chicago 근무 직원명, 봉급
SELECT E.NAME, E.SALARY
FROM EMPLOYEES E
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE D.LOCATION = 'Chicago';
-- 봉급 5000 이상 10000이하 직원 이름 부서 봉급
SELECT E.NAME, D.DEPARTMENT_NAME, E.SALARY
FROM EMPLOYEES E
LEFT OUTER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.SALARY >= 5000 AND E.SALARY <= 10000;

--6.최근 3개월 내 입사한 직원

SELECT NAME, HIRE_DATE
FROM EMPLOYEES
WHERE ABS(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) <= 3;

--7.부서장 이름 조회

SELECT D.DEPARTMENT_NAME, E.NAME
FROM DEPARTMENTS D
LEFT OUTER JOIN EMPLOYEES E ON D.MANAGER_ID = E.EMPLOYEE_ID;

--8.직무별 직원 수 조회

SELECT JOB_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY JOB_ID;

--9.부서별 평균 급여

SELECT D.DEPARTMENT_NAME, CEIL(AVG(E.SALARY))
FROM EMPLOYEES E
RIGHT OUTER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME;

--10.직원의 총 급여 합계

SELECT SUM(SALARY)
FROM EMPLOYEES;

--11.대출 정보와 고객 이름 조회
SELECT L.AMOUNT, C.NAME
FROM LOANS L
LEFT OUTER JOIN CUSTOMERS C ON L.CUSTOMER_ID = C.CUSTOMER_ID
ORDER BY AMOUNT ;

--12.대출 상태별 고객 수
SELECT STATUS, COUNT(DISTINCT CUSTOMER_ID)
FROM LOANS
GROUP BY STATUS;

--13.직원수가 가장 적은 부서
SELECT DEPARTMENT_ID, COUNT(*) AS COUNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
ORDER BY COUNT 
FETCH FIRST 1 ROW ONLY;

--14.월별 신규 고객 수
SELECT TO_CHAR(CREATED_AT, 'YYYY-MM'),COUNT(*)
FROM CUSTOMERS
GROUP BY TO_CHAR(CREATED_AT, 'YYYY-MM')
ORDER BY TO_CHAR(CREATED_AT, 'YYYY-MM') DESC;

--15.상품 카테고리 계층 구조 조회
SELECT S1.CATEGORY_NAME, S2.CATEGORY_NAME, S3.CATEGORY_NAME
FROM SHOPPING_CATEGORIES S1
LEFT OUTER JOIN SHOPPING_CATEGORIES S2 ON S1.PARENT_CATEGORY_ID = S2.CATEGORY_ID
LEFT OUTER JOIN SHOPPING_CATEGORIES S3 ON S2.PARENT_CATEGORY_ID = S3.CATEGORY_ID;

--16.특정 지점의 대출 합계
SELECT FLOOR(SUM(L.AMOUNT))
FROM BRANCHES B
JOIN LOANS L ON B.BRANCH_ID = L.BRANCH_ID
WHERE B.NAME = 'Branch 8';

--17.직무별 직원의 평균 급여와 급여 등급 조회
SELECT JOB_ID, AVG(SALARY),
       CASE
            WHEN AVG(SALARY) >= 8000 THEN 'HIGH'
            WHEN AVG(SALARY) < 8000 AND AVG(SALARY) >= 6000 THEN 'EMDIUM'
            WHEN AVG(SALARY) < 6000 THEN 'LOW'
        END
        AS AVG_SALARY
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) >= 5000
ORDER BY AVG(SALARY) DESC;

--18.고객별 거래 내역
SELECT C.NAME, T.TRANSACTION_TYPE, T.AMOUNT
FROM CUSTOMERS C 
JOIN ACCOUNTS A ON A.CUSTOMER_ID = C.CUSTOMER_ID
JOIN TRANSACTIONS T ON T.ACCOUNT_ID = A.ACCOUNT_ID
ORDER BY C.NAME;

--19.부서별 직원의 평균 입사일 차이
SELECT JOB_ID, ROUND(AVG(SYSDATE - HIRE_DATE),0)
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;


--20.대출 금액 상위 5명 고객 조회
SELECT C.NAME, L.AMOUNT
FROM LOANS L
JOIN CUSTOMERS C ON L.CUSTOMER_ID = C.CUSTOMER_ID
WHERE L.STATUS = 'APPROVED'
ORDER BY L.AMOUNT DESC, TO_NUMBER(SUBSTR(C.NAME, 10))
FETCH FIRST 5 ROW ONLY;
```
