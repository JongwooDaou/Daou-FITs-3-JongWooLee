# TIL: 데이터베이스
## 학습날짜: 2025년 1월 22일

## Problem: 
- 처음 배우는 생소한 내용들에 대한 이해도 부족

## Solution:
- 직접 코드를 작성하며 눈에 익히기

## What I Learned

### 그룹 함수
- 데이터를 특정 기준으로 그룹핑하여 요약, 집계하는 데 사용
- 데이터 분석 및 보고서를 생성할 때 유용한 기술
- 다차원 데이터를 요약하는 데 활용
- ROLLUP: 특정 컬럼 순서대로 부분 합계 및 총합계를 계산
- CUBE: 모든 컬럼의 가능한 조합에 대해 다차원 집계를 계산
- GROUPING SETS: 지정된 그룹핑 조합에 대해서만 집계를 계산
- GROUPING: 집계 데이터와 실제 데이터를 구분하는 데 사용

### 그룹 함수 연습
```sql
--그룹함수
--기본
SELECT JOB_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY JOB_ID, DEPARTMENT_ID
ORDER BY JOB_ID, DEPARTMENT_ID;

--ROLLUP
SELECT JOB_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;

--CUBE
SELECT JOB_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY CUBE(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY CUBE(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;

--GROUPING SETS
SELECT JOB_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
GROUP BY GROUPING SETS(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY GROUPING SETS(JOB_ID, DEPARTMENT_ID,())
ORDER BY JOB_ID, DEPARTMENT_ID;

--UNION ALL로 표현
SELECT JOB_ID,
    NULL AS DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY JOB_ID
UNION ALL
SELECT NULL,
    DEPARTMENT_ID,
    COUNT(*) AS CNT
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
ORDER BY JOB_ID, DEPARTMENT_ID;

--GROUPING
SELECT JOB_ID,
    COUNT(*) AS CNT,
    GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;

SELECT JOB_ID,
    DEPARTMENT_ID,
    COUNT(*) AS CNT,
    GROUPING(JOB_ID),
    GROUPING(DEPARTMENT_ID)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY ROLLUP(JOB_ID, DEPARTMENT_ID)
ORDER BY JOB_ID, DEPARTMENT_ID;

SELECT CASE
        WHEN GROUPING(JOB_ID) = 0 THEN JOB_ID
        WHEN GROUPING(JOB_ID) = 1 THEN 'TOTAL'
       END JOB_ID,
    COUNT(*) AS CNT,
    GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(JOB_ID)
ORDER BY JOB_ID;
```

### 뷰
- SQL 쿼리 결과를 기반으로 만들어지는 가상 테이블
- 실제 데이터를 저장하지 않고 테이블처럼 동작
- 복잡한 쿼리를 단순화하고 데이터 보안을 강화
- 복잡한 쿼리를 단순화하여 사용자가 쉽게 접근 가능
- 특정 열 또는 행에 대한 접근을 제한하여 보안 강화
- 기본 테이블 구조를 추상화하여 데이터 변경 시 유연성 제공
- 재사용 가능한 쿼리 인터페이스 제공
- 단순 뷰: 단일 테이블을 기반
- 복합 뷰: 여러 테이블, 함수 또는 그룹화를 포함
- 물리적 뷰: 쿼리 결과를 물리적으로 저장하여 성능 향상

### 시퀀스
- 자동으로 고유한 숫자를 생성하는 오라클 객체
- 주로 기본 키나 고유한 값이 필요한 컬럼에 사용
- 고유한 숫자 생성 보장
- 숫자의 증감 방향 설정 가능
- 생성 규칙 정의 가능
- 캐싱을 사용하여 성능 최적화 가능


