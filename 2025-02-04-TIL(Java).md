# TIL: Java
## 학습날짜: 2025년 2월 4일

## Problem:
- 사용은 가능하나 깊은 지식 부족

## Solution:
- 기초이론 부터 처음부터 학습

## What I Learned


### 자바 언어 특징
- 운영체제에 독립적 jvm을 통해
- 일반적인 언어는 컴파일러가 하이레벨 랭귀지로 작성된 코드를 머신코드로 변경
  (머신코드 - 특정 운영체제에서만 이용가능)
- 자바의 경우 컴파일러를 통해서 바이트 코드로 변경
  변경된 바이트 코드를 JVM이 읽어들여서 머신코드로 변경해서 실행
  ( .java -> (javac compiler) -> .class )

- java는 객체지향 언어
- 운영체제에 독립적
- API가 잘 되어 있음


### 절차적 언어
 - 대표적인 언어가 C
 - 기능으로 프로그램을 세분화 시킴
 - 더이상 분할 할 수 없는 단위기능이 나오게 모두 분할
 - 이 단위기능을 함수로 구현
 - 설계와 구현이 쉽고 결과적으로 비용적인 이점
 - 유지보수가 힘들다
 - 이 문제를 해결하기 위한 프로그래밍 패러다임이 변화 => 객체지향 프로그래밍
 - 해결해야 하는 현실세계를 프로그램으로 모델링하는 작업을 한 후에 프로그래밍 진행

### JVM, JRE, JDK
- JVM: bytecode를 읽어들여서 실행하는 실행 주체
- JRE(Java Runtime Environment): 자바실행환경 
  JVM + Java Class library
  프로그램을 실행하기 위한 여러 라이브러리들을 포함
- JDK(Java Development Kit): 자바 개발도구
  JRE + 자바개발도구(javac, java, javadoc, etc..)

### Java의 객체지향
- 현실세계의 구현해야 하는 문제를 프로그래밍적으로 표현(모델링)을 하는 구현 방법론.
- 해결해야 하는 문제를 구성하고 있는 구성요소를 파악 이 구성요소를 파악한 후 프로그램으로 표현 필요
- 추상화(Abstranction)을 거쳐서 나온 여러가지 정보를 상태와 행위로 구분
 ( ex. 상태(잔액, 나이, 주소, 주민번호 ...), 행위(이체, 출금, 대출...)
- 상태는 변수(fields) 행위는 함수(method)로 표현
- field와 method는 class라는 단위로 묶음
- class라는 단위는 객체 모델링을 하기 위한 수단으로 사용
- class의 첫번째 의미는 객체 모델링의 수단
- Java program은 class의 집합으로 표현될 수 있다.
- 일반 적으로 코드로 표현할 때 class 1개당 파일 1개 매핑( 클래스의 이름은 파일이름으로 명명)


### Class
- 객체 지향의 수단
- 추상 데이터 타입
- instace를 파생 시키는 수단

``` java
class Customer{
	//fields
	String name; // 고객이름
	int age;	  // 고객 나이
	int height;	  // 고객의 키

	//constructor(생성자)
	//인스턴스를 생성하기 위해서 필요



	//methods
	//함수들
}
```
-클래스로부터 저장공간을 생성해서 그 저장공간을 이요해서 프로그래밍을 진행
-instance가 저장공간을 의미, 동적으로 생기는 메모리는 힙에 배치
-class는 결국 데이터 타입의 역할을 수행함
-고정된 데이터 타입이 아니기 때문에 추상데이터타입(ADT: Abstract Data Type)
-자바 프로그램은 class의 집합
-하나의 프로그램 내에서는 상당히 많은 class들이 존재
-클래스를 효율적으로 관리하기 위해 논리적인 개념인 package(물리적으로는 directory 생성)
-package를 만들지 않으면 자동으로 unnamed package에 할당

### Java의 데이터 타입
- Java는 Strong type language 변수를 선언할 때 변수의 데이터 타입을 지정해서 변수를 선언
- 대소문자를 구분하고변수길이의 제한이 없다.
- 예약어로 변수 설정이 불가하다.
- 숫자로 시작하는 변수는 만들 수 없다.
- 특수문자는 _와 $만 허용.
- 클래스 이름은 PascalCase  (ex. MyFreind)
- 일반 변수 이름은 camelCase  (ex. myFriend)
- 데이터 타입은 크게 2가지로 나뉜다.
 1.primitive data type(8가지: byte, short. int, long, float, double, char, boolnean)  
   정수형: byte(1 byte) short(2 byte) int(4 byte) long(8 byte)  
   실수형: float double  
   문자형: char  
   논리형: boolean  
   해당 타입으로 선언된 변수안에 직접 데이터가 저장  
 2.reference data type(class)  
   클래스로 선언된 변수를 지칭  
   이 타입으로 선언된 변수안에는 메모리 주소(해싱되어있음)가 저장  
- 변수말고 상수도 존재(final이라는 keyword를 사용하여 상수를 표현) 상수 표현시 대문자 SNAKE_CASE  
- 형변환을 주의해서 사용  
  1. 묵시적 형변환(implicit)  
  2. 명시적 형변환(casting)  
``` java
	double phi = 3.1415926;
        int myData = (int)phi; //casting 명시적 형변환

        double k = 10 + 20.0; //int + double 묵시적 형변환

```
### Overloading
- 같은 이름이나 같은 형태로 여러개의 기능을 수행하는 경우
- 연산자 overloading, method Overloading( parameter의 타입이나 갯수가 다른 경우), 생성자 Overloading
```java
    public class InstanceTest {

    int a = 4;

    public InstanceTest(){

    }
    public InstanceTest(int num){
        this.a = num;
    }

    public static void main(String[] args) {
        InstanceTest d = new InstanceTest();
        InstanceTest e = new InstanceTest(5);

        System.out.println(d.a); //4
        System.out.println(e.a); //5
    }
}
```



== 자바 실행 순서
- method Area, stack, heap
- static 없을 경우
- 1.program 실행 시 클래스에 대한 정보가 method Area에 올라감( field와 main()을 포함한 method모두)
  2.,main() 을 먼저 찾아 스택에 올린 후 실행
  3. 객체는 heap 영역에 생성(field의 실제 메모리 공간 할당, method의 실행 코드는 method area에 있기 때문에 코드가 직접 들어가지 않음.
  4. stack의 main안의 객체의 지역변수에 primative type일 경우 직접 값을 할당하고 아닐경우 힙 영역 주소값을 참조함.
  5.실행이 완료 된 후 스택의 main종료.
  6. 힙 내부의 사용할 수 없는 인스턴스를 garbage collector가 지움
  7. method area에 클래스에 대한 정보를 삭제
- static 있을경우
```java
public class InstanceTest {
    //static field or static variable, class variable
    static int a = staticCall("1번");

    //instance variable
    int b = staticCall("2번");

    //static method
    public static int staticCall(String msg){
        System.out.println(msg);
        return 100;
    }

    //constructor 기본 생성자는 명시하는 것이 좋다.
    //생성자는 인스턴스를 생성하기 위해서 반드시 호출
    //만들어진 인스턴스를 초기화하는 역할
    public InstanceTest(){
        this.b = staticCall("3번");
    }


    public static void main(String[] args) {
        System.out.println("4번");
        int c = staticCall("5번");
        InstanceTest d = new InstanceTest();
    }
}
```
- 1.Method Area 에 InstanceTest정보가 올라감
  2.Method Area 에 static field인 int a가 직접 할당됨( 프로그램 실행 하자마자, main  실행 전)
  3.int b에 대한 정보 할당( 직접 할당x)
  4. staticCall()과 생성자의 코드, main 할당
  5. 메인 stack 에 올라가 "4번" 출력
  6. int C 스택에 할당 후 staticCall() "5번"출력 후 int c = 100 할당
  7. heap 영역에 new keyword에 의해서 인스턴스를 생성
  8. int b 할당 하면서 staticCall("2번") 실행 후 100 할당
  9. 생성자 method가 실행 되면서 staticCall("3번")  실행
